Aidan Mokalla

----
checkpoint:
----

So far I have only completed up to step 3.1, drawing the BÃ©zier curve
in the overview.

----
post-checkpoint:
----

I updated my curve drawing to match the specification accurately
when a segment is more acutely curved.

My "segments" helper functions actually deals in triangles /
triangular segments, but the name matches your specification.

I've included a HEIGHT parameter for the height of the mirror.

When an object intersects with the mirror, in only a handful of cases
this results in a disjointed effect where the object is not
completely flush with its reflection in the mirror. Because this edge
case (no pun intended) is very rare, and because there is some
approximation error introduced during interpolation, and because this
effect mirrors (again no pun intended) how objects in meatspace leave
a gap with their reflections even when pressed directly against a
mirror with non-zero thickness (i.e. the layer of glass atop the
mirror), I have not included my solution to this phenomenon.

My original solution was just to prohibit objects from being updated
if they would have intersected with the mirror, similar to how they
bounce off of one another. But that seemed rude. So it's a feature,
not a bug !!

----
bells and whistles:
----

I implemented soft shadows using pseudorandomness from a hash function
for GLSL and other randomization tools throughout found here: 
    gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
This is why there are some artifacts in the shadow. It treats the
light as an area light source by sampling points within a disc of
radius LIGHT_RADIUS around the light position. For each
surface point, SHADOW_SAMPLES rays are traced to "random" points on
this disc, and the shadow intensity is the proportion of rays that
reach the light without being blocked. The parameters LIGHT_RADIUS
and SHADOW_SAMPLES can be adjusted to trade off between softness and
performance.

I've added a basic physics simulation, which runs just as fast as
without. (The frame rate was especially slow when the mirror was
displayd both before and after this physics implementation). Spheres are
initialized with a random velocity vector, and they can bounce off
the walls and each other. When a sphere hits a wall, its velocity is
reversed and dampened by 5%. This is handled by calculating the collision
normal and applying impulses to both spheres to separate them and adjust
their velocities. The mass of each sphere is proportional to its radius
cubed. The time step `dt` is calculated proportionally to the time
elapsed since the last update to give movement independent of frame rate.
The control points for the mirror also move randomly within the scene
bounds. Their velocities are updated with small random changes, and they
also bounce off the scene boundaries with damping. They move away from
one another as well as from the spheres.

The shader now samples multiple slightly perturbed reflection directions 
within a cone to implement stochastic ray tracing for the mirror and
reflective sphere. The perturbations are generated by random samples in a
unit sphere, scaled by a small spread factor.

----
POST-DEADLINE UPDATE:
----

23 hours post-deadline:

I updated the sphere collision handling to accurately take into account
the spheres' heights in order to allow overlapping sphere projections
along the z axis. 

3 days post-deadline:

I have implemented mirror self-reflection in bezier-funhouse.html using a
capped loop. I also cleaned my code up a bit and added a button to freeze
the control points from moving which makes it easier to demonstrate the
mirror self-reflection.

